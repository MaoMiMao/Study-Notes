[TOC]

UI

### Java内存区 域与内存溢出异常

java虚拟机在执行java程序的过程中将所管理的内存划分为若干个不同的数据区域

![1550818920830](F:\笔记\Java\虚拟机\1550818920830.png)

#### 程序计数器

**当前线程**所执行的字节码的行号指示器。

任何一个确定时刻，一个处理器(多核处理器的一个内核)只会执行一条线程中的指令

注：本地方法栈是唯一一个在java虚拟机规范中没有规定任何OutofMemoryError的情况

#### 虚拟机栈

线程私有 生命周期与线程相同 用于描述java方法执行的内存模型。每一个方法从调用到截至就对应着一个栈帧在虚拟机栈从入栈到出栈的过程 栈帧是确定的

当请求栈帧深度大于虚拟机允许深度 stackOverflowError 

当虚拟机栈动态扩展时无法请求道足够的内存 OutOfMemoryError

#### 本地方法栈

为虚拟机使用到的Native方法服务

#### 堆

Java堆被所有线程共享的一块内存区域，在虚拟机启动时创建。作用是存放**对象实例**

#### 方法区

 线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据

##### 运行时常量池

方法区的一部分、用于存放编译期生成的各种字面量和符号引用 

### 垃圾收集器与内存分配 策略

#### 判断对象是否存活

- **引用计数** 
- **根搜索算法**

![1551143619939](F:\笔记\Java\虚拟机\1551143619939.png)

##### **引用**

- 强引用： 只要强引用还存在，垃圾收集器就不会回收 
- 软引用： 系统将要发生内存溢出异常之前，将对象列进回收范围进行二次回收 (softRefrence)
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集发生之前 (weakRefrence)
- 虚引起：一个对象时候有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例(PhantReference)

##### **回收方法区**

主要回收**废弃常量**和**无用的类**

无用的类：

1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
2. 加载该类的ClassLoader已经被回收
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

#### 垃圾收集算法

##### 标记-清除算法

##### 复制算法 (Eden 1 Survivor 2)

**标记-整理算法**

**分代收集算法**

#### 内存分配与回收策略

**给对象分配内存**以及**回收分配给对象的内存**

收集器ParNew/SerialOld为例

- 对象优先在Eden中分配
- 大对象直接进入老年代( PretenureSizeThreshould 可设置大小)
- 长期存活的对象进入老年代(每经过一次MinGC加1 达到默认次数进入老年代 MaxTenuringThreshold 设置阈值)
- 动态年龄判定 只要survivor中相同年龄所有对象大小总和大于Survivor的一半 年龄大于等于该年龄的对象可以直接进入老年代
- 空间分配担保 发生MinorGC时 需检查每次晋升老年代的平均大小是否大于老年代的剩余空间大小 如果大于 该为FullGC 如果小于 查看设置是否允许失败 是 MinorGC 否 FullGC

```
-XX:+PrintGC 输出GC日志

-XX:+PrintGCDetails 输出GC的详细日志

-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）

-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式）

-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息

-Xloggc:../logs/gc.log 日志文件的输出路径

```



### 虚拟机行内监控与故障处理

![1551162128555](F:\笔记\Java\虚拟机\1551162128555.png)

### 案例